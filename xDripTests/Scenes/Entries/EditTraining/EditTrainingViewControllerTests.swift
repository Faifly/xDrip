//
//  EditTrainingViewControllerTests.swift
//  xDrip
//
//  Created by Artem Kalmykov on 17.03.2020.
//  Copyright (c) 2020 Faifly. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import xDrip
import XCTest

// swiftlint:disable implicitly_unwrapped_optional

final class EditTrainingViewControllerTests: XCTestCase {
    // MARK: Subject under test
    
    var sut: EditTrainingViewController!
    var window: UIWindow!
    
    // MARK: Test lifecycle
    
    override func setUp() {
        super.setUp()
        window = UIWindow()
        sut = EditTrainingViewController()
    }
    
    override func tearDown() {
        window = nil
        super.tearDown()
    }
    
    func loadView() {
        window.addSubview(sut.view)
        RunLoop.current.run(until: Date())
    }
    
    // MARK: Test doubles

    final class EditTrainingBusinessLogicSpy: EditTrainingBusinessLogic {
        var doLoadCalled = false
        var doCancelCalled = false
        var doSaveCalled = false

        func doLoad(request: EditTraining.Load.Request) {
            doLoadCalled = true
        }
        
        func doCancel(request: EditTraining.Cancel.Request) {
            doCancelCalled = true
        }
        
        func doSave(request: EditTraining.Done.Request) {
            doSaveCalled = true
        }
    }

    // MARK: Tests

    func testShouldDoLoadWhenViewIsLoaded() {
        // Given
        let spy = EditTrainingBusinessLogicSpy()
        sut.interactor = spy

        // When
        loadView()

        // Then
        XCTAssertTrue(spy.doLoadCalled, "viewDidLoad() should ask the interactor to do load")
    }
    
    func testDoCancel() {
        // Given
        let spy = EditTrainingBusinessLogicSpy()
        sut.interactor = spy
        loadView()
        let cancelButton = sut.navigationItem.leftBarButtonItem
        
        // When
        _ = cancelButton?.target?.perform(cancelButton?.action, with: nil)
        
        // Then
        XCTAssertTrue(spy.doCancelCalled)
    }
    
    func testDoSave() {
        // Given
        let spy = EditTrainingBusinessLogicSpy()
        sut.interactor = spy
        loadView()
        let saveButton = sut.navigationItem.rightBarButtonItem
        
        // When
        _ = saveButton?.target?.perform(saveButton?.action, with: nil)
        
        // Then
        XCTAssertTrue(spy.doSaveCalled)
    }

    func testDisplayLoad() {
        // Given
        let tableViewModel = BaseSettings.ViewModel(sections: [])
        let viewModel = EditTraining.Load.ViewModel(tableViewModel: tableViewModel)

        // When
        loadView()
        sut.displayLoad(viewModel: viewModel)

        // Then
    }
    
    func testDataChangedHandlers() {
        // Given
        let trainingEntry = TrainingEntry(duration: TimeInterval.secondsPerHour, intensity: .default, date: Date())
        
        // When
        sut.router?.dataStore?.mode = .edit(trainingEntry)
        loadView()
        let tableView = getTableView()
        
        guard
            let durationPicker = getPicker(tableView, at: IndexPath(row: 0, section: 0)) as? CustomPickerView,
            let intensityPicker = getPicker(tableView, at: IndexPath(row: 1, section: 0)) as? CustomPickerView
        else {
            XCTFail("Cannot obtain intensity picker")
            return
        }
        
        durationPicker.selectRow(1, inComponent: 0, animated: false)
        durationPicker.pickerView(durationPicker, didSelectRow: 1, inComponent: 0)
        
        durationPicker.selectRow(0, inComponent: 0, animated: false)
        durationPicker.pickerView(durationPicker, didSelectRow: 0, inComponent: 0)
        
        intensityPicker.selectRow(1, inComponent: 0, animated: false)
        intensityPicker.pickerView(intensityPicker, didSelectRow: 1, inComponent: 0)
        
        let button = sut.navigationItem.rightBarButtonItem
        _ = button?.target?.perform(button?.action, with: nil)
    }
    
    func testDateChangedHandler() {
        // When
        sut.router?.dataStore?.mode = .create
        loadView()
        let tableView = getTableView()
        
        guard let datePicker = getPicker(tableView, at: IndexPath(row: 2, section: 0)) as? CustomDatePicker else {
            XCTFail("Cannot obtain date picker")
            return
        }
        
        datePicker.date = Date().addingTimeInterval(-TimeInterval.secondsPerMinute)
        datePicker.sendActions(for: .valueChanged)
        
        let button = sut.navigationItem.rightBarButtonItem
        _ = button?.target?.perform(button?.action, with: nil)
    }
    
    func testDetailTextChanges() {
        // Given
        let cellType = PickerExpandableTableViewCell.self
        let accessibilityID = "detailLabel"
        
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy/MM/dd HH:mm"
        let specificDate = formatter.date(from: "2000/10/01 09:41")
        
        let trainingEntry = TrainingEntry(
            duration: TimeInterval.secondsPerHour,
            intensity: .high,
            date: specificDate ?? Date()
        )
        
        // When
        sut.router?.dataStore?.mode = .edit(trainingEntry)
        loadView()
        let tableView = getTableView()
        
        guard
            let durationPickerCell = tableView.getCell(of: cellType, at: IndexPath(row: 0, section: 0)),
            let durationDetailLabel = durationPickerCell.findView(with: accessibilityID) as? UILabel
        else {
            XCTFail("Cannot obtain duration picker cell")
            return
        }
        
        guard
            let intensityPickerCell = tableView.getCell(of: cellType, at: IndexPath(row: 1, section: 0)),
            let intensityDetailLabel = intensityPickerCell.findView(with: accessibilityID) as? UILabel
        else {
            XCTFail("Cannot obtain intensity picker cell")
            return
        }
        
        guard
            let datePickerCell = tableView.getCell(of: cellType, at: IndexPath(row: 2, section: 0)),
            let dateDetailLabel = datePickerCell.findView(with: accessibilityID) as? UILabel
        else {
            XCTFail("Cannot obtain date picker cell")
            return
        }
        
        // Then
        XCTAssertTrue(durationDetailLabel.text == "60 m")
        XCTAssertTrue(intensityDetailLabel.text == "edit_training_intensity_high".localized)
        XCTAssertTrue(dateDetailLabel.text == DateFormatter.localizedString(
            from: specificDate ?? Date(),
            dateStyle: .short,
            timeStyle: .short
        ))
    }
    
    // MARK: Support methods
    
    private func getTableView() -> UITableView {
        guard let tableView = sut.view.subviews.compactMap({ $0 as? UITableView }).first else {
            XCTFail("Cannot obtain tableView")
            fatalError()
        }
        
        return tableView
    }
    
    private func getPicker(_ tableView: UITableView, at indexPath: IndexPath) -> PickerView? {
        let cellType = PickerExpandableTableViewCell.self
        guard let pickerCell = tableView.getCell(of: cellType, at: indexPath) else {
            XCTFail("Cannot obtain picker cell")
            return nil
        }
        
        pickerCell.togglePickerVisibility()
        
        guard let stackView = pickerCell.contentView.subviews.compactMap({ $0 as? UIStackView }).first,
            let picker = stackView.arrangedSubviews.first as? PickerView else {
            XCTFail("Cannot obtain picker")
            return nil
        }
        
        return picker
    }
}
