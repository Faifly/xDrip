//
//  SettingsRootViewControllerTests.swift
//  xDrip
//
//  Created by Artem Kalmykov on 11.03.2020.
//  Copyright (c) 2020 Faifly. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import xDrip
import XCTest

// swiftlint:disable implicitly_unwrapped_optional

final class SettingsRootViewControllerTests: XCTestCase {
    // MARK: Subject under test
    
    var sut: SettingsRootViewController!
    var window: UIWindow!
    
    // MARK: Test lifecycle
    
    override func setUp() {
        super.setUp()
        window = UIWindow()
        setupSettingsRootViewController()
    }
    
    override func tearDown() {
        window = nil
        super.tearDown()
    }
    
    // MARK: Test setup
    
    func setupSettingsRootViewController() {
        sut = SettingsRootViewController()
    }
    
    func loadView() {
        window.addSubview(sut.view)
        RunLoop.current.run(until: Date())
    }
    
    // MARK: Test doubles
    
    final class SettingsRootBusinessLogicSpy: SettingsRootBusinessLogic {
        var doLoadCalled = false
        var cancelCalled = false
        
        func doLoad(request: SettingsRoot.Load.Request) {
            doLoadCalled = true
        }
        
        func doCancel(request: SettingsRoot.Cancel.Request) {
            cancelCalled = true
        }
    }
    
    final class SettingsRootRoutingLogicSpy: SettingsRootRoutingLogic {
        var toUnitsCalled = false
        var toChartSettingsCalled = false
        var toAlertRootCalled = false
        var toCloudUploadsCalled = false
        var toTransmitterCalled = false
        var toRangeSelectionCalled = false
        var toModeSettingsCalled = false
        var toUserTypeCalled = false
        var toSensorCalled = false
        var toNightscoutServiceCalled = false
        
        func dismissSelf() { }
        
        func routeToUnits() {
            toUnitsCalled = true
        }
        
        func routeToChartSettings() {
            toChartSettingsCalled = true
        }
        
        func routeToAlertRoot() {
            toAlertRootCalled = true
        }
        
        func routeToCloudUploads() {
            toCloudUploadsCalled = true
        }
        
        func routeToTransmitter() {
            toTransmitterCalled = true
        }
        
        func routeToRangeSelection() {
            toRangeSelectionCalled = true
        }
        
        func routeToModeSettings() {
            toModeSettingsCalled = true
        }
        
        func routeToUserType() {
            toUserTypeCalled = true
        }
        
        func routeToSensor() {
            toSensorCalled = true
        }
        
        func routeToNightscoutService() {
            toNightscoutServiceCalled = true
        }
    }
    
    // MARK: Tests
    
    func testShouldDoLoadWhenViewIsLoaded() {
        // Given
        let spy = SettingsRootBusinessLogicSpy()
        sut.interactor = spy
        
        // When
        loadView()
        
        // Then
        XCTAssertTrue(spy.doLoadCalled, "viewDidLoad() should ask the interactor to do load")
    }
    
    func testDisplayLoad() {
        // Given
        let viewModel = SettingsRoot.Load.ViewModel(tableViewModel: BaseSettings.ViewModel(sections: []))
        
        // When
        loadView()
        sut.displayLoad(viewModel: viewModel)
        
        // Then
    }
    
    func testCancelHandler() {
        // Given
        let spy = SettingsRootBusinessLogicSpy()
        sut.interactor = spy
        loadView()
        
        guard let target = sut.navigationItem.leftBarButtonItem?.target else {
            fatalError()
        }
        guard let action = sut.navigationItem.leftBarButtonItem?.action else {
            fatalError()
        }
        
        // When
        _ = target.perform(action)
        
        // Given
        XCTAssertTrue(spy.cancelCalled)
    }
    
    func testSingleSelectionHandler() {
        User.current.settings.updateDeviceMode(.main)
        User.current.settings.updateInjectionType(.pen)
        
        let spy = SettingsRootRoutingLogicSpy()
        if let interactor = sut.interactor as? SettingsRootInteractor {
            interactor.router = spy
        }
        
        loadView()
        
        guard let tableView = sut.view.subviews.compactMap({ $0 as? UITableView }).first else {
            XCTFail("Cannot obtain tableView")
            return
        }
        
        XCTAssertTrue(tableView.numberOfSections == 2)
        XCTAssertTrue(tableView.numberOfRows(inSection: 0) == 6)
        XCTAssertTrue(tableView.numberOfRows(inSection: 1) == 5)
        
        // When
        tableView.callDidSelect(at: IndexPath(row: 0, section: 0))
        // Then
        XCTAssertTrue(spy.toChartSettingsCalled)
        
        // When
        tableView.callDidSelect(at: IndexPath(row: 1, section: 0))
        // Then
        XCTAssertTrue(spy.toAlertRootCalled)
        
        // When
        tableView.callDidSelect(at: IndexPath(row: 2, section: 0))
        // Then
        XCTAssertTrue(spy.toCloudUploadsCalled)
        
        // When
        tableView.callDidSelect(at: IndexPath(row: 3, section: 0))
        // Then
        XCTAssertTrue(spy.toModeSettingsCalled)
        
        // When
        tableView.callDidSelect(at: IndexPath(row: 4, section: 0))
        // Then
        XCTAssertTrue(spy.toSensorCalled)
        
        // When
        tableView.callDidSelect(at: IndexPath(row: 5, section: 0))
        // Then
        XCTAssertTrue(spy.toTransmitterCalled)
        
        // When
        User.current.settings.updateDeviceMode(.follower)
        NotificationCenter.default.postSettingsChangeNotification(setting: .deviceMode)
        // Then
        XCTAssertTrue(tableView.numberOfRows(inSection: 0) == 4)
        
        // When
        tableView.callDidSelect(at: IndexPath(row: 0, section: 1))
        // Then
        XCTAssertTrue(spy.toRangeSelectionCalled)
        
        // When
        tableView.callDidSelect(at: IndexPath(row: 1, section: 1))
        // Then
        XCTAssertTrue(spy.toUserTypeCalled)
        
        // When
        tableView.callDidSelect(at: IndexPath(row: 2, section: 1))
        // Then
        XCTAssertTrue(spy.toUnitsCalled)
        
        // When
        User.current.settings.updateInjectionType(.pump)
        NotificationCenter.default.postSettingsChangeNotification(setting: .injectionType)
        // Then
        XCTAssertTrue(tableView.numberOfSections == 3)
        XCTAssertTrue(tableView.numberOfRows(inSection: 2) == 1)
        
        // When
        tableView.callDidSelect(at: IndexPath(row: 0, section: 2))
        // Then
        XCTAssertTrue(spy.toNightscoutServiceCalled)
    }
    
    func testTimePickerValueChanged() {
        loadView()
        
        guard let tableView = sut.view.subviews.compactMap({ $0 as? UITableView }).first else {
            XCTFail("Cannot obtain tableView")
            return
        }
        
        let cellType = PickerExpandableTableViewCell.self
        guard let carbsCell = tableView.getCell(of: cellType, at: IndexPath(row: 3, section: 1)),
            let insulinCell = tableView.getCell(of: cellType, at: IndexPath(row: 4, section: 1)) else {
            XCTFail("Cannot obtain picker cells")
            return
        }
        
        carbsCell.togglePickerVisibility()
        insulinCell.togglePickerVisibility()
        
        guard let carbsStackView = carbsCell.contentView.subviews.compactMap({ $0 as? UIStackView }).first,
            let insulinStackView = insulinCell.contentView.subviews.compactMap({ $0 as? UIStackView }).first,
            let carbsPicker = carbsStackView.arrangedSubviews.first as? CustomPickerView,
            let insulinPicker = insulinStackView.arrangedSubviews.first as? CustomPickerView else {
            XCTFail("Cannot obtain pickers")
            return
        }
        
        let settings = User.current.settings
        var time = 10.0 * TimeInterval.secondsPerHour + 10.0 * TimeInterval.secondsPerMinute
        
        // When
        carbsPicker.selectRow(10, inComponent: 0, animated: false)
        carbsPicker.selectRow(10, inComponent: 2, animated: false)
        carbsPicker.pickerView(carbsPicker, didSelectRow: 0, inComponent: 1)
        // Then
        XCTAssertTrue(settings?.carbsAbsorptionRate == time)
        
        // When
        insulinPicker.selectRow(15, inComponent: 0, animated: false)
        insulinPicker.selectRow(15, inComponent: 2, animated: false)
        insulinPicker.pickerView(insulinPicker, didSelectRow: 0, inComponent: 1)
        
        time = 15.0 * TimeInterval.secondsPerHour + 15.0 * TimeInterval.secondsPerMinute
        // Then
        XCTAssertTrue(settings?.insulinActionTime == time)
    }
}
