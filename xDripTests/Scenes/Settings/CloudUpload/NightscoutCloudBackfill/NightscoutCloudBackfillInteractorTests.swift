//
//  NightscoutCloudBackfillInteractorTests.swift
//  xDrip
//
//  Created by Artem Kalmykov on 09.04.2020.
//  Copyright (c) 2020 Faifly. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import xDrip
import XCTest

// swiftlint:disable implicitly_unwrapped_optional

final class NightscoutCloudBackfillInteractorTests: AbstractRealmTest {
    // MARK: Subject under test
    
    var sut: NightscoutCloudBackfillInteractor!
    var settings: NightscoutSyncSettings!
    
    // MARK: Test lifecycle
    
    override func setUp() {
        super.setUp()
        setupNightscoutCloudBackfillInteractor()
        do { try initSettings() } catch { XCTFail("Couldn't init NightscoutSyncSettings") }
    }
    
    func initSettings() throws {
        settings = try XCTUnwrap(User.current.settings.nightscoutSync)
        settings.updateIsEnabled(true)
        settings.updateUploadTreatments(true)
        settings.updateBaseURL("baseURL")
        settings.updateAPISecret("apiSecret")
    }
    
    override func tearDown() {
        super.tearDown()
    }
    
    // MARK: Test setup
    
    func setupNightscoutCloudBackfillInteractor() {
        sut = NightscoutCloudBackfillInteractor()
    }
    
    // MARK: Test doubles
    
    final class NightscoutCloudBackfillPresentationLogicSpy: NightscoutCloudBackfillPresentationLogic {
        var presentLoadCalled = false
        
        func presentLoad(response: NightscoutCloudBackfill.Load.Response) {
            presentLoadCalled = true
        }
    }
    
    final class NightscoutCloudBackfillRoutingLogicSpy: NightscoutCloudBackfillRoutingLogic {
        func presentPopUp(message: String, success: Bool) {
        }
    }
    
    // MARK: Tests
    
    func testDoLoad() {
        // Given
        let spy = NightscoutCloudBackfillPresentationLogicSpy()
        sut.presenter = spy
        let request = NightscoutCloudBackfill.Load.Request()
        
        // When
        sut.doLoad(request: request)
        
        // Then
        XCTAssertTrue(spy.presentLoadCalled, "doLoad(request:) should ask the presenter to format the result")
    }
    
    func testDoSend() throws {
        // Given
        CGMDevice.current.updateMetadata(
            ofType: .sensorAge,
            value: "\((Date() - .secondsPerDay).timeIntervalSince1970)"
        )
        CGMDevice.current.updateSensorIsStarted(true)
        let date = Date().addingTimeInterval(.secondsPerHour)
        let reading = GlucoseReading()
        reading.setValue(date, forKey: "date")
        reading.setValue(130.0, forKey: "rawValue")
        reading.generateID()
        
        realm.safeWrite {
            realm.add(reading)
        }
        
        let carbEntry = CarbEntry(amount: 1.0, foodType: "1.2", date: date)
        realm.safeWrite {
            realm.add(carbEntry)
        }
        let request = NightscoutCloudBackfill.Send.Request()
        
        let mirror = NightscoutServiceMirror(object: NightscoutService.shared)
        
        var postGlucoseResult: Bool {
            var result = false
            do { result = try XCTUnwrap(mirror.requestQueue).contains(where: {
                $0.type == .postGlucoseReading
            }) } catch { XCTFail("Couldn't Unwrap NightscoutServiceMirror") }
            
            return result
        }
        
        var postCarbResult: Bool {
            var result = false
            do { result = try XCTUnwrap(mirror.requestQueue).contains(where: {
                $0.type == .postCarbs
            }) } catch { XCTFail("Couldn't Unwrap NightscoutServiceMirror") }
            
            return result
        }
        
        XCTAssertFalse(postCarbResult)
        XCTAssertFalse(postGlucoseResult)
        
        // When
        reading.updateCalculatedValue(1.0)
        reading.updateCloudUploadStatus(.uploaded)
        carbEntry.updateCloudUploadStatus(.uploaded)
        sut.doSend(request: request)

        // Then
        XCTAssertTrue(reading.cloudUploadStatus == .notUploaded)
        XCTAssertTrue(carbEntry.cloudUploadStatus == .notUploaded)
        XCTAssertTrue(postCarbResult)
        XCTAssertTrue(postGlucoseResult)
        
        CarbEntriesWorker.deleteCarbsEntry(carbEntry)
    }
}
