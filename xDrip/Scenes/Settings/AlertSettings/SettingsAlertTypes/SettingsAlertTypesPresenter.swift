//
//  SettingsAlertTypesPresenter.swift
//  xDrip
//
//  Created by Artem Kalmykov on 09.04.2020.
//  Copyright (c) 2020 Faifly. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol SettingsAlertTypesPresentationLogic {
    func presentLoad(response: SettingsAlertTypes.Load.Response)
}

final class SettingsAlertTypesPresenter: SettingsAlertTypesPresentationLogic {
    weak var viewController: SettingsAlertTypesDisplayLogic?
    
    // MARK: Do something
    
    func presentLoad(response: SettingsAlertTypes.Load.Response) {
        let tableViewModel = BaseSettings.ViewModel(
            sections: [
                createDefaultConfigurationSection(response: response),
                createEventsSection(response: response)
            ]
        )
        
        let viewModel = SettingsAlertTypes.Load.ViewModel(tableViewModel: tableViewModel)
        viewController?.displayLoad(viewModel: viewModel)
    }
    
    private func createDefaultConfigurationSection(response: SettingsAlertTypes.Load.Response) -> BaseSettings.Section {
        let settings = User.current.settings.alert?.defaultConfiguration ?? AlertConfiguration()
        
        let cells: [BaseSettings.Cell] = [
            createTextInputViewCell(
                .name,
                detailText: settings.name,
                placeholder: settings.eventType.title,
                editingChangedHandler: response.defaultSectionTextEditingChangedHandler
            ),
            createRightSwitchCell(
                .snoozeFromNotification,
                isSwitchOn: settings.snoozeFromNotification,
                switchValueChangedHandler: response.defaultSectionSwitchHandler
            ),
            createTimePickerView(
                .defaultSnooze,
                detail: settings.defaultSnooze,
                valueChangeHandler: response.defaultSectionPickerValueChangedHandler
            ),
            createRightSwitchCell(
                .repeat,
                isSwitchOn: settings.repeat,
                switchValueChangedHandler: response.defaultSectionSwitchHandler
            ),
            createDisclosureCell(
                mainText: SettingsAlertTypes.Field.sound.title,
                detailText: nil,
                index: 0,
                selectionHandler: response.defaultSectionSelectionHandler
            ),
            createRightSwitchCell(
                .vibrate,
                isSwitchOn: settings.isVibrating,
                switchValueChangedHandler: response.defaultSectionSwitchHandler
            )
        ]
        
        return .normal(cells: cells, header: "settings_alert_types_default_header".localized, footer: nil)
    }
    
    private func createEventsSection(response: SettingsAlertTypes.Load.Response) -> BaseSettings.Section {
        let settings = User.current.settings.alert ?? AlertSettings()
        var cells: [BaseSettings.Cell] = []
        
        var alertTypes = AlertEventType.allCases
        alertTypes.removeAll(where: { $0 == .default })
        
        for (index, alertType) in alertTypes.enumerated() {
            let config = settings.customConfiguration(for: alertType)
            
            cells.append(
                createDisclosureCell(
                    mainText: config.name ?? alertType.title,
                    detailText: nil,
                    index: index,
                    selectionHandler: response.eventsSectionSelectionHandler
                )
            )
        }
        
        return .normal(cells: cells, header: "settings_alert_types_events_header".localized, footer: nil)
    }
    
    private func createTextInputViewCell(
        _ field: SettingsAlertTypes.Field,
        detailText: String?,
        placeholder: String?,
        editingChangedHandler: @escaping (String) -> Void) -> BaseSettings.Cell {
        return .textInput(mainText: field.title, detailText: detailText, placeholder: placeholder) { string in
            guard let string = string else { return }
            editingChangedHandler(string)
        }
    }
    
    private func createRightSwitchCell(
        _ field: SettingsAlertTypes.Field,
        isSwitchOn: Bool,
        switchValueChangedHandler: @escaping (SettingsAlertTypes.Field, Bool) -> Void) -> BaseSettings.Cell {
        return .rightSwitch(text: field.title, isSwitchOn: isSwitchOn) { value in
            switchValueChangedHandler(field, value)
        }
    }
    
    private func createTimePickerView(
        _ field: SettingsAlertTypes.Field,
        detail: TimeInterval?,
        valueChangeHandler: @escaping (TimeInterval) -> Void) -> BaseSettings.Cell {
        var detailText = "\(Int((detail ?? 0.0) / TimeInterval.secondsPerMinute)) "
        detailText += "settings_alert_types_minutes".localized
        
        let picker = CustomPickerView(mode: .countDown)
        
        if let detail = detail {
            let hour = Int(detail / TimeInterval.secondsPerHour)
            var minutes = detail - (TimeInterval(hour) * TimeInterval.secondsPerHour)
            minutes /= TimeInterval.secondsPerMinute
            
            picker.selectRow(hour, inComponent: 0, animated: false)
            picker.selectRow(Int(minutes), inComponent: 2, animated: false)
        }
        
        picker.formatValues = { strings in
            guard strings.count > 3 else { return "" }
            
            let hourString = strings[0]
            let minuteString = strings[2]
            
            guard let hour = Double(hourString), let minute = Double(minuteString) else { return "" }
            
            let time = minute * TimeInterval.secondsPerMinute + hour * TimeInterval.secondsPerHour
            
            valueChangeHandler(TimeInterval(time))
            
            return "\(Int(time / TimeInterval.secondsPerMinute)) " + "settings_alert_types_minutes".localized
        }
        
        return .pickerExpandable(mainText: field.title, detailText: detailText, picker: picker)
    }
    
    private func createDisclosureCell(
        mainText: String,
        detailText: String?,
        index: Int,
        selectionHandler: @escaping (Int) -> Void) -> BaseSettings.Cell {
        return .disclosure(mainText: mainText, detailText: detailText) {
            selectionHandler(index + 1)
        }
    }
}

private extension SettingsAlertTypes.Field {
    var title: String {
        switch self {
        case .name: return "settings_alert_types_default_name".localized
        case .snoozeFromNotification: return "settings_alert_types_default_snooze_from_notification".localized
        case .defaultSnooze: return "settings_alert_types_default_snooze".localized
        case .repeat: return "settings_alert_types_default_repeat".localized
        case .sound: return "settings_alert_types_default_sound".localized
        case .vibrate: return "settings_alert_types_default_vibrate".localized
        }
    }
}

private extension AlertEventType {
    var title: String {
        switch self {
        case .default: return "settings_alert_types_event_type_title_default".localized
        case .fastRise: return "settings_alert_types_event_type_title_fast_rise".localized
        case .urgentHigh: return "settings_alert_types_event_type_title_urgent_high".localized
        case .high: return "settings_alert_types_event_type_title_high".localized
        case .fastDrop: return "settings_alert_types_event_type_title_fast_drop".localized
        case .low: return "settings_alert_types_event_type_title_low".localized
        case .urgentLow: return "settings_alert_types_event_type_title_urgent_low".localized
        case .missedReadings: return "settings_alert_types_event_type_title_missed_readings".localized
        case .phoneMuted: return "settings_alert_types_event_type_title_phone_muted".localized
        }
    }
}
