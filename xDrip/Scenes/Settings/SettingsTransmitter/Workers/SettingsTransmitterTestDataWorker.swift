//
//  SettingsTransmitterTestDataWorker.swift
//  xDrip
//
//  Created by Artem Kalmykov on 07.08.2020.
//  Copyright (c) 2020 Faifly. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import RealmSwift

// swiftlint:disable function_body_length

protocol SettingsTransmitterTestDataWorkerLogic {
    func generateTestData(configuration: SettingsTransmitter.TestBackfillConfiguration,
                          callback: @escaping (Int, Int) -> Void)
}

final class SettingsTransmitterTestDataWorker: SettingsTransmitterTestDataWorkerLogic {
    private let glucoseStepMin = 0.1 * 1000.0
    
    func generateTestData(configuration: SettingsTransmitter.TestBackfillConfiguration,
                          callback: @escaping (Int, Int) -> Void) {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            self?.startDataGeneration(configuration: configuration, callback: callback)
        }
    }
    
    private func startDataGeneration(configuration: SettingsTransmitter.TestBackfillConfiguration,
                                     callback: @escaping (Int, Int) -> Void) {
        if let service = CGMController.shared.service as? MockedBluetoothService {
            service.isPaused = true
        }
        Calibration.deleteAll()
        Realm.shared.safeWrite {
            Realm.shared.delete(GlucoseReading.allMaster)
        }
        
        Realm.shared.safeWrite {
            Realm.shared.delete(Realm.shared.objects(LightGlucoseReading.self))
        }
        
        let backfillInterval = TimeInterval(configuration.days) * .secondsPerDay
        let readingsInterval = TimeInterval(configuration.minutesBetweenReading) * .secondsPerMinute
        
        let now = Date()
        var currentOffset = now.timeIntervalSince1970 - backfillInterval
        
        let readingsAmount = Int(backfillInterval / readingsInterval)
        var currentGlucose = configuration.minGlucose * 1000
        var increment = 1.0
        
        CGMDevice.current.sensorStartDate = Date(timeIntervalSince1970: currentOffset - .secondsPerHour * 3.0)
        CGMDevice.current.updateSensorIsStarted(true)
        
        for index in 0..<readingsAmount {
            autoreleasepool {
                callback(index, readingsAmount)
                
                GlucoseReading.create(
                    filtered: currentGlucose,
                    unfiltered: currentGlucose,
                    rssi: 100.0,
                    date: Date(timeIntervalSince1970: currentOffset),
                    requireCalibration: false
                )
                
                if index == 1 {
                    try? Calibration.createInitialCalibration(
                        glucoseLevel1: currentGlucose / 1000.0,
                        glucoseLevel2: currentGlucose / 1000.0 + 1.0,
                        date1: Date(timeIntervalSince1970: currentOffset),
                        date2: Date(timeIntervalSince1970: currentOffset)
                    )
                }
                
                currentOffset += readingsInterval
                
                let step = Double.random(in: glucoseStepMin...configuration.maxStepDeviation * 1000.0)
                
                if configuration.isChaotic {
                    if currentGlucose + configuration.maxStepDeviation * 1000.0 > configuration.maxGlucose * 1000.0 {
                        currentGlucose -= step
                    } else if currentGlucose - configuration.maxStepDeviation * 1000.0 < configuration.minGlucose * 1000.0 {
                        currentGlucose += step
                    } else {
                        if Bool.random() {
                            currentGlucose += step
                        } else {
                            currentGlucose -= step
                        }
                    }
                } else {
                    currentGlucose += increment * step
                    
                    if currentGlucose >= configuration.maxGlucose * 1000.0 && increment > 0 {
                        increment = -1.0
                    } else if currentGlucose <= configuration.minGlucose * 1000.0 && increment < 0 {
                        increment = 1.0
                    }
                }
            }
        }
        
        if let service = CGMController.shared.service as? MockedBluetoothService {
            service.isPaused = false
        }
    }
}
